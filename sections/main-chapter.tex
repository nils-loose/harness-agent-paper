\section{Automated Harness Generation}%
\label{sec:approach}
We present an agent-based approach to automated fuzzing harness generation that addresses several fundamental challenges of generating effective harnesses for complex library APIs. Our approach combines LLM-powered agents with static analysis and dynamic coverage feedback to iteratively construct and refine harnesses that achieve deep code coverage.
Figure~\ref{fig:overview} illustrates our workflow as a sequence of transformations that progressively refine a fuzzing harness. After initializing the environment by downloading library artifacts and preparing analysis infrastructure, the workflow proceeds through three phases: target research to understand API semantics, harness construction through code generation and compilation, and iterative coverage-guided refinement. Specialized ReAct agents~\cite{DBLP:conf/iclr/YaoZYDSN023:ReAct} orchestrate each phase, querying documentation and source code on demand to maintain focused context while exploring large dependency graphs.
\subsection{Static Analysis and Instrumentation}%
\label{subsec:static-analysis}
\input{figures/coverage-tracking-sample.tex}
Our approach requires three preprocessing artifacts that enable efficient agent exploration and accurate coverage measurement. First, we extract API documentation from Javadoc HTML archives distributed with Maven artifacts, parsing method signatures and parameter descriptions using Beautiful Soup~\cite{beautifulsoup} to provide agents with concise API contracts indexed for query-based retrieval. Second, we compute a static callgraph rooted at the target method using SootUp's Class Hierarchy Analysis~\cite{DBLP:conf/tacas/KarakayaSKBSLH24:SootUp}, traversing method invocations to depth~10 (depth~5 for large libraries). Each node records the method signature, enclosing class, and distance from the target, serving to scope coverage analysis to reachable methods and provide agents with structural context about call dependencies. Third, we implement method-targeted coverage instrumentation. Standard coverage instrumentation measures all executed code, creating a misaligned incentive for agents to invoke unrelated utility methods. We address this by extending JaCoCo~\cite{jacoco} with runtime toggling of coverage tracking, accessible through a runtime API. Using ASM~\cite{asm} for offline bytecode instrumentation, we wrap target method invocations to enable coverage recording only during target execution (Listing~\ref{lst:coverage-tracking}), ensuring metrics reflect the target's behavior rather than incidental framework initialization.
%
%
\subsection{Tool-Augmented Exploration}%
\label{subsec:tool-augmented-exploration}
\input{figures/mcp-design.tex}
%
We expose preprocessing artifacts to agents through a query-based interface using the Model Context Protocol (MCP)~\cite{mcp}, enabling on-demand retrieval of tailored information as reasoning progresses.
%
%\paragraph{Tool Interface Design}
We provide three tool categories: documentation queries, source code retrieval, and callgraph queries. Figure~\ref{fig:mcp-design} illustrates the MCP initialization process. Each tool accepts structured parameters (e.g., class name, method signature) and returns responses optimized for LLM consumption: concise method signatures, minimal code snippets, and depth-limited callgraph fragments.
\input{tables/mcp-overview.tex}
%\paragraph{Role-Based Tool Access}
To prevent exploration drift, we restrict tool access based on agent role. Table~\ref{tab:tool-availability} summarizes tool availability across the five ReAct agents. All agents access documentation and source code tools for foundational API understanding, while callgraph tools are restricted to the coverage analysis agent for interpreting coverage gaps. This role-based access control prevents agents from pursuing information irrelevant to their current task.

% Commented out to save space - MCP tool schema details not essential
% \input{figures/mcp-registration.tex}
%
\subsection{Target Research}%
\label{subsec:target-research}

Following environment initialization (Maven download, documentation extraction, callgraph construction), the research agent transforms the target method signature into contextual knowledge about API semantics. The agent is initialized with the target method's signature, documentation, and source code, then iteratively queries additional documentation and source code through MCP tools. Figure~\ref{fig:research-sequence} illustrates this query-driven exploration pattern. Rather than exhaustively extracting all available information, the agent follows its reasoning to identify relevant patterns: required initialization sequences, factory method usage, and implicit preconditions. The agent produces a natural language research report structured with predefined markdown sections that organize findings without constraining content to rigid schemas, accommodating diverse API designs.
\input{figures/research-sequence.tex}
\subsection{Harness Generation}%
\label{subsec:harness-generation}

The research report is transformed into compilable code through two sequential steps: generation and compilation. The generation agent synthesizes initial harness code that instantiates the target method with fuzzer-generated inputs. The agent has access to the Jazzer API documentation and queries additional source code to resolve ambiguities in constructor signatures or factory method usage. A critical aspect of harness synthesis is exception handling: the agent must determine which exceptions represent expected API behavior (e.g., IllegalArgumentException for invalid inputs) that should be caught to continue fuzzing, versus unexpected exceptions that indicate bugs and must propagate to Jazzer's crash detection. The agent analyzes API documentation and method signatures to infer expected exception contracts, synthesizing appropriate try-catch blocks that preserve bug-finding capability. The agent outputs harness source code and a list of Maven dependencies. Separating research from generation prevents context saturation: research explores broadly without committing to code structure, while generation focuses narrowly on producing syntactically valid harness code.

If the compile step fails, a compilation agent iteratively resolves build errors by analyzing compiler diagnostics, querying source code and documentation to understand the root cause, and producing corrected code until compilation succeeds or an iteration limit is reached. Common error patterns include missing imports, incorrect method signatures, and improper exception handling. Independent compilation repair allows targeted iteration budgets distinct from initial synthesis, reflecting the need for precise syntactic correctness in the final artifact.
\subsection{Coverage-Guided Refinement}%
\label{subsec:coverage-guided-refinement}

Once compilation succeeds, the compiled harness is instrumented and executed under fuzzing to collect initial coverage data. An iterative refinement loop then uses this coverage feedback to improve harness effectiveness through two collaborative agents: a coverage analysis agent that interprets coverage gaps and decides whether refinement is worthwhile, and a refinement agent that modifies the harness.

%\paragraph{Coverage Analysis and Termination}
To seed the coverage analysis, we merge method-level coverage data with the static callgraph to produce an annotated view showing coverage status for each reachable method, grouped by call depth from the target. The coverage analysis agent explores uncovered or partially covered methods by querying their source code and documentation to determine whether gaps reflect addressable harness deficiencies (missing input diversity, unexplored API paths) or fundamental limitations (unreachable defensive code, external I/O dependencies). The agent then makes a termination decision: stop if further refinement yields diminishing returns, or continue with a strategy targeting specific uncovered methods.

%\paragraph{Harness Refinement}
If refinement continues, the refinement agent receives the current harness code, the coverage analysis strategy (priority methods and improvement rationale), and annotated coverage data. The agent modifies the harness to exercise uncovered code paths through strategies such as diversifying input generation, invoking alternative API paths, or triggering exception handlers through edge-case inputs. The refined harness re-enters compilation and fuzzing, creating a feedback loop that continues until the coverage agent determines refinement yields diminishing returns or an iteration limit is reached. Convergence detection through code hashing prevents oscillation between semantically equivalent harness variants.
