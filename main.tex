\documentclass[sigconf,review,anonymous]{acmart}

\usepackage{listings}
\usepackage[inkscapeopt={-D}]{svg}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{pifont}
\usepackage{rotating}
\usepackage{listings}
\usepackage{xcolor}

% YAML syntax highlighting - clean for academic papers
\lstdefinestyle{yaml}{
  basicstyle=\ttfamily\small,
  sensitive=false,
  comment=[l]{\#},
  commentstyle=\color{gray},
  showstringspaces=false,
  emphstyle=\bfseries,
  emph={get_method_code,description,method_signature,type,class_name,default},
  identifierstyle=,
  keywords={null, string},
}

% Java syntax highlighting
\definecolor{javared}{rgb}{0.6,0,0}          % for strings
\definecolor{javagreen}{rgb}{0.25,0.5,0.35}  % for comments
\definecolor{javapurple}{rgb}{0.5,0,0.35}    % for keywords
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75} % for javadoc

\lstset{language=Java,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{javapurple}\bfseries,
  stringstyle=\color{javared},
  commentstyle=\color{javagreen},
  morecomment=[s][\color{javadocblue}]{/**}{*/},
  showstringspaces=false,
  tabsize=2
}

% Define checkmark symbol
\newcommand{\cmark}{\ding{51}}

\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}
\acmConference[Conference acronym 'XX]{Make sure to enter the correct
  conference title from your rights confirmation email}{June 03--05,
  2018}{Woodstock, NY}
\acmISBN{978-1-4503-XXXX-X/2018/06}
\acmSubmissionID{123}
% Define text styles for SVG rendering
\def\axtext{\footnotesize\sffamily}
\def\ticktext{\scriptsize\sffamily}


\begin{document}

\title{Multi-Agent Driven Fuzz-Harness Generation}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Ben Trovato}
\authornote{Both authors contributed equally to this research.}
\email{trovato@corporation.com}
\orcid{1234-5678-9012}
\author{G.K.M. Tobin}
\authornotemark[1]
\email{webmaster@marysville-ohio.com}
\affiliation{%
  \institution{Institute for Clarity in Documentation}
  \city{Dublin}
  \state{Ohio}
  \country{USA}
}

\author{Lars Th{\o}rv{\"a}ld}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

\author{Valerie B\'eranger}
\affiliation{%
  \institution{Inria Paris-Rocquencourt}
  \city{Rocquencourt}
  \country{France}
}

\author{Aparna Patel}
\affiliation{%
 \institution{Rajiv Gandhi University}
 \city{Doimukh}
 \state{Arunachal Pradesh}
 \country{India}}

\author{Huifen Chan}
\affiliation{%
  \institution{Tsinghua University}
  \city{Haidian Qu}
  \state{Beijing Shi}
  \country{China}}

\author{Charles Palmer}
\affiliation{%
  \institution{Palmer Research Laboratories}
  \city{San Antonio}
  \state{Texas}
  \country{USA}}
\email{cpalmer@prl.com}

\author{John Smith}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \city{Hekla}
  \country{Iceland}}
\email{jsmith@affiliation.org}

\author{Julius P. Kumquat}
\affiliation{%
  \institution{The Kumquat Consortium}
  \city{New York}
  \country{USA}}
\email{jpkumquat@consortium.net}

\renewcommand{\shortauthors}{Trovato et al.}


\begin{abstract}
Coverage-guided fuzzing requires high-quality harnesses to exercise library code, yet manual harness creation remains a bottleneck—particularly for Java libraries with complex Maven dependencies, reflection-based initialization, and deep inheritance hierarchies. Existing approaches mine usage patterns from consumer code or derive harnesses from type signatures, but struggle with unavailable corpora or non-obvious API contracts. Recent LLM-based systems face context saturation when preprocessing entire API surfaces and lack mechanisms to interpret coverage feedback semantically.
%
We present a multi-agent architecture that integrates LLM reasoning with targeted code analysis to automate Java harness generation. Five specialized ReAct agents decompose the workflow into research, synthesis, compilation repair, coverage analysis, and refinement—querying documentation, source code, and callgraph information on demand through the Model Context Protocol. Two technical innovations enable effective coverage-guided refinement: method-targeted instrumentation that activates coverage tracking only during target method execution, and agent-guided termination that interprets coverage gaps by examining uncovered methods to distinguish addressable deficiencies from fundamental limitations.
%
Evaluation on seven target methods from six widely-deployed Java libraries (115,000+ Maven dependents) shows our harnesses achieve competitive coverage with manually-written OSS-Fuzz baselines and AutoFuzz at \$3.20 and approximately 10 minutes per harness. During 12-hour fuzzing campaigns, our harnesses triggered 14 crashes revealing 3 unique bugs in production libraries already integrated into OSS-Fuzz.
\end{abstract}
%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10010147.10010257</concept_id>
       <concept_desc>Computing methodologies~Machine learning</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007</concept_id>
       <concept_desc>Software and its engineering</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006</concept_id>
       <concept_desc>Software and its engineering~Software notations and tools</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10002978.10003022</concept_id>
       <concept_desc>Security and privacy~Software and application security</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computing methodologies~Machine learning}
\ccsdesc[500]{Software and its engineering}
\ccsdesc[500]{Software and its engineering~Software notations and tools}
\ccsdesc[500]{Security and privacy~Software and application security}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{fuzzing, fuzz harness generation, large language models, multi-agent systems, automated software testing, program analysis, feedback-driven refinement, Java ecosystem, coverage-guided fuzzing, software security}


\maketitle

\section{Introduction}

Coverage-guided fuzzing has become the gold standard for discovering vulnerabilities in systems software, yet its effectiveness on library code fundamentally depends on the availability of high-quality fuzz harnesses. A harness bridges unstructured fuzzer inputs to structured API invocations, transforming raw bytes into valid method calls that exercise library logic. Manual harness creation remains the principal bottleneck limiting fuzzing coverage: developers must reverse-engineer API preconditions, synthesize realistic call sequences, and navigate complex dependency graphs. In ecosystems like Java, where libraries require intricate Maven configurations and reflection-based initialization, harness authoring has proven particularly challenging.

Existing automated approaches face complementary limitations, and crucially, most work has focused on C/C++ libraries rather than managed runtime environments. Usage-based methods mine API patterns from client code but require rich consumer corpora—unavailable for niche or newly-released libraries~\cite{DBLP:conf/sigsoft/BabicBCIKKLSW19:FUDGE,DBLP:conf/sp/JeongJYMKJKSH23:UTopia}. Structure-based methods derive harnesses from type signatures but struggle with non-obvious API contracts and often depend on domain-specific heuristics~\cite{DBLP:conf/icse/GreenA22:GraphFuzz,DBLP:conf/icse/ShermanN25:OGHarn}. Feedback-driven refinement shows promise but typically focuses on narrow domains or lacks robust mechanisms to resolve build failures~\cite{DBLP:conf/uss:ZhangLZZZZXLL0H23:Rubick}. While recent LLM-based systems demonstrate progress through coverage-guided prompt evolution~\cite{DBLP:conf/ccs/LyuXCC24:PromptFuzz} and knowledge graph augmentation~\cite{DBLP:conf/icse:XuMZZCHLW25:CKGFuzzer}, Java libraries present distinct challenges: complex Maven dependency resolution, reflection-heavy initialization patterns, and deep inheritance hierarchies that resist simple type-based harness generation. No existing approach provides fully automated, end-to-end synthesis for Java libraries without manual intervention or reliance on external consumer code.

Large language models offer a path forward by combining code synthesis capabilities with learned API usage patterns. However, applying LLMs to harness generation introduces new challenges: preprocessing entire API surfaces exhausts context windows, one-shot generation fails on complex libraries requiring multi-step initialization, and coverage-based refinement risks semantic drift without mechanisms to interpret what coverage gaps actually mean. These challenges demand a fundamentally different approach—one that integrates LLM reasoning with code analysis rather than treating generation as pure synthesis, and that retrieves information on demand rather than preprocessing everything upfront.

We address this through a multi-agent architecture that combines specialized ReAct agents with targeted code analysis. Five agents decompose harness generation into distinct reasoning tasks: research (API exploration through documentation and source code), synthesis (initial code generation), compilation repair (build error diagnosis), coverage analysis (gap interpretation via callgraph and source inspection), and refinement (targeted harness improvement). Rather than preprocessing entire API surfaces into static knowledge graphs, agents query information on demand through the Model Context Protocol—retrieving documentation for specific methods, source code for targeted classes, and callgraph fragments rooted at particular invocations. This query-driven approach maintains focused context while exploring large dependency graphs, enabling the workflow to autonomously handle Maven dependency resolution, reflection-heavy initialization patterns, and iterative compilation repair without manual intervention.

Two technical innovations enable effective coverage-guided refinement. First, we introduce method-targeted coverage instrumentation through runtime-toggled JaCoCo tracking that activates only during target method execution. Standard instrumentation measures all executed code, creating misaligned incentives where harnesses invoke unrelated utility methods to inflate metrics; our scoping ensures coverage reflects target behavior rather than incidental framework initialization. Second, we delegate termination decisions to an agent that interprets coverage gaps by examining uncovered methods' source code to distinguish addressable deficiencies (missing input variants, unexplored API paths) from fundamental limitations (unreachable defensive code, external I/O dependencies). This interpretation enables stopping when refinement yields diminishing returns while continuing when concrete improvement strategies exist.

We evaluate our approach on seven target methods from six widely-deployed Java libraries (commons-cli, gson, guava, jackson-databind, jsoup, antlr4) totaling 115,000+ Maven dependents. Our generated harnesses match or outperform coverage achieved by OSS-Fuzz's manually-written harnesses and Jazzer's AutoFuzz reflection-based generation. Generation costs average \$3.20 and approximately 10 minutes per harness, making the approach practical for iterative fuzzing workflows. Critically, our harnesses triggered 14 crashes during 12-hour fuzzing campaigns, revealing 3 unique bugs (2 in commons-cli, 1 in jsoup)—demonstrating that automatically-generated harnesses achieve sufficient input diversity to find real vulnerabilities in production libraries already integrated into OSS-Fuzz. In one striking example (ANTLR4), our generated harness achieved measurable coverage on a method where the existing OSS-Fuzz harness registered 0\% coverage throughout the campaign, unable to satisfy preconditions required to reach the target.

This work makes the following contributions:
\begin{itemize}
    \item A multi-agent architecture integrating LLM reasoning with code analysis to fully automate harness generation for Java libraries.

    \item A query-driven tool interface using the Model Context Protocol that retrieves precisely scoped information on demand, preventing the context saturation that limits one-shot generation.

    \item Method-targeted coverage instrumentation with agent-guided termination that interprets coverage gaps through source code analysis rather than applying fixed thresholds.

    \item Empirical validation demonstrating competitive coverage with OSS-Fuzz baselines, practical generation costs (\$3.20, approximately 10 minutes per harness), and discovery of 3 unique bugs in production libraries.
\end{itemize}


\input{figures/overview.tex}
\input{sections/preliminaries.tex}
\input{sections/main-chapter.tex}
\input{sections/evaluation.tex}
\input{sections/related-work.tex}

\section{Conclusion and Outlook}

We presented a multi-agent architecture that integrates LLM reasoning with code analysis to fully automate fuzzing harness generation for Java libraries. By combining query-driven information retrieval through the Model Context Protocol with method-targeted coverage instrumentation and agent-guided termination, our approach achieves competitive coverage with manually-written OSS-Fuzz baselines while discovering real vulnerabilities in production libraries. With generation costs averaging \$3.20 and approximately 10 minutes per harness, the approach demonstrates practical feasibility for integration into continuous fuzzing workflows.

%\input{sections/threads-to-validity.tex}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{main}


\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.