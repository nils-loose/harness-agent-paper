\documentclass[sigconf,review,anonymous]{acmart}

\usepackage{listings}
\usepackage[inkscapeopt={-D}]{svg}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{pifont}
\usepackage{rotating}
\usepackage{listings}
\usepackage{xcolor}

% YAML syntax highlighting - clean for academic papers
\lstdefinestyle{yaml}{
  basicstyle=\ttfamily\small,
  sensitive=false,
  comment=[l]{\#},
  commentstyle=\color{gray},
  showstringspaces=false,
  emphstyle=\bfseries,
  emph={get_method_code,description,method_signature,type,class_name,default},
  identifierstyle=,
  keywords={null, string},
}

% Java syntax highlighting
\definecolor{javared}{rgb}{0.6,0,0}          % for strings
\definecolor{javagreen}{rgb}{0.25,0.5,0.35}  % for comments
\definecolor{javapurple}{rgb}{0.5,0,0.35}    % for keywords
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75} % for javadoc

\lstset{language=Java,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{javapurple}\bfseries,
  stringstyle=\color{javared},
  commentstyle=\color{javagreen},
  morecomment=[s][\color{javadocblue}]{/**}{*/},
  showstringspaces=false,
  tabsize=2
}

% Define checkmark symbol
\newcommand{\cmark}{\ding{51}}

\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}
\acmConference[Conference acronym 'XX]{Make sure to enter the correct
  conference title from your rights confirmation email}{June 03--05,
  2018}{Woodstock, NY}
\acmISBN{978-1-4503-XXXX-X/2018/06}
\acmSubmissionID{123}
% Define text styles for SVG rendering
\def\axtext{\footnotesize\sffamily}
\def\ticktext{\scriptsize\sffamily}


\begin{document}

\title{Multi-Agent Driven Fuzz-Harness Generation}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Ben Trovato}
\authornote{Both authors contributed equally to this research.}
\email{trovato@corporation.com}
\orcid{1234-5678-9012}
\author{G.K.M. Tobin}
\authornotemark[1]
\email{webmaster@marysville-ohio.com}
\affiliation{%
  \institution{Institute for Clarity in Documentation}
  \city{Dublin}
  \state{Ohio}
  \country{USA}
}

\author{Lars Th{\o}rv{\"a}ld}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

\author{Valerie B\'eranger}
\affiliation{%
  \institution{Inria Paris-Rocquencourt}
  \city{Rocquencourt}
  \country{France}
}

\author{Aparna Patel}
\affiliation{%
 \institution{Rajiv Gandhi University}
 \city{Doimukh}
 \state{Arunachal Pradesh}
 \country{India}}

\author{Huifen Chan}
\affiliation{%
  \institution{Tsinghua University}
  \city{Haidian Qu}
  \state{Beijing Shi}
  \country{China}}

\author{Charles Palmer}
\affiliation{%
  \institution{Palmer Research Laboratories}
  \city{San Antonio}
  \state{Texas}
  \country{USA}}
\email{cpalmer@prl.com}

\author{John Smith}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \city{Hekla}
  \country{Iceland}}
\email{jsmith@affiliation.org}

\author{Julius P. Kumquat}
\affiliation{%
  \institution{The Kumquat Consortium}
  \city{New York}
  \country{USA}}
\email{jpkumquat@consortium.net}

\renewcommand{\shortauthors}{Trovato et al.}


\begin{abstract}
TODO: Klaus generate Abstract
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10010147.10010257</concept_id>
       <concept_desc>Computing methodologies~Machine learning</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007</concept_id>
       <concept_desc>Software and its engineering</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006</concept_id>
       <concept_desc>Software and its engineering~Software notations and tools</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10002978.10003022</concept_id>
       <concept_desc>Security and privacy~Software and application security</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computing methodologies~Machine learning}
\ccsdesc[500]{Software and its engineering}
\ccsdesc[500]{Software and its engineering~Software notations and tools}
\ccsdesc[500]{Security and privacy~Software and application security}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{fuzzing, fuzz harness generation, large language models, multi-agent systems, automated software testing, program analysis, feedback-driven refinement, Java ecosystem, coverage-guided fuzzing, software security}


\maketitle

\section{Introduction}

Coverage-guided fuzzing has emerged as the dominant approach for discovering robustness vulnerabilities in systems software, libraries, and frameworks~\cite{CITE}. Yet its effectiveness on \emph{library code} fundamentally depends on the availability of high-quality \emph{fuzz harnesses}, i.e., specialized programs that bridge unstructured fuzzer inputs to structured API invocations. Manual harness construction remains a formidable barrier to scalable library fuzzing: developers must reverse-engineer API preconditions, synthesize realistic call sequences, and navigate complex build environments with transitive dependencies and environmental constraints. In ecosystems like Java, where libraries often require intricate Maven dependency graphs, reflection-based initialization, and runtime configuration, harness authoring has become the principal bottleneck limiting fuzzing coverage.

The research community has pursued three complementary strategies to automate harness generation. \emph{Usage-based approaches} mine API call patterns from existing client code or test suites, repurposing observed interactions as fuzzing drivers~\cite{DBLP:conf/sigsoft/BabicBCIKKLSW19:FUDGE, DBLP:conf/uss/IspoglouAMP20:FuzzGen, DBLP:conf/sp/JeongJYMKJKSH23:UTopia, DBLP:conf/icse/ZhangZLWLZJ23:Daisy, DBLP:journals/pacmse/WuNH25:WildSync}. While these methods capture realistic usage patterns, they inherently require rich consumer corpora, a condition rarely satisfied for niche libraries, legacy codebases, or newly released APIs. \emph{Structure- and API-based approaches} circumvent this limitation by deriving harnesses directly from type signatures, interface specifications, or dataflow graphs~\cite{DBLP:conf/icse/ZhangLMZ021:IntelliGen, DBLP:conf/icse/GreenA22:GraphFuzz, DBLP:conf/ccs/ChenXLWC23:Hopper, DBLP:conf/issta/XiongDCQWSZ24:Atlas, DBLP:journals/pacmse/ToffaliniBTP25:LibErator, DBLP:conf/icse/ShermanN25:OGHarn, DBLP:conf/ndss/0007ZLSZLQ25:NEXZZER}. However, these techniques struggle with non-obvious API contracts and often depend on domain-specific heuristics or human-in-the-loop guidance to resolve ambiguities. \emph{Feedback-driven approaches} close the loop through iterative refinement, using compilation errors, runtime exceptions, or coverage signals to guide harness evolution~\cite{DBLP:conf/uss/ZhangLZZZZXLL0H23:Rubick, DBLP:journals/pacmse/ToffaliniBTP25:LibErator, DBLP:conf/icse/ShermanN25:OGHarn, DBLP:conf/ndss/0007ZLSZLQ25:NEXZZER}. Despite their promise, existing feedback systems typically focus on narrow domains or lack robust mechanisms to automatically resolve build failures and environmental misconfigurations.

Large Language Models (LLMs) offer a path forward by combining code synthesis capabilities with learned knowledge of API usage patterns and debugging strategies. Early work has explored LLM-driven harness generation, revealing both opportunities and fundamental challenges: semantic drift under iterative refinement, brittleness to build system variations, and difficulties grounding generation in concrete coverage objectives~\cite{DBLP:conf/issta/ZhangZBLMXLSL24:HowEffectiveAreThey, DBLP:conf/sigsoft/Jiang0MCZSWFWLZ24:WhenFuzzingMeetsLLMs}. Recent systems have demonstrated progress through coverage-guided prompt evolution~\cite{DBLP:conf/ccs/LyuXCC24:PromptFuzz}, knowledge graph augmentation~\cite{DBLP:conf/icse/XuMZZCHLW25:CKGFuzzer}, and multi-agent coordination~\cite{DBLP:journals/corr/abs-2507-18289:Scheduzz}. However, a critical gap remains: no existing approach provides a fully automated, end-to-end pipeline that handles environment preparation, synthesis, compilation repair, and coverage-driven optimization without manual intervention.

We address this gap through a multi-agent system designed specifically for Java library fuzzing. Java serves as an ideal target for several reasons. First, its ecosystem comprises millions of Maven-hosted libraries that form the backbone of enterprise software infrastructure~\cite{CITE}, creating both high-impact fuzzing opportunities and a representative testbed for automation techniques. Second, Java's characteristics, i.e., deep dependency graphs, reflection-heavy APIs, and complex runtime requirements, stress-test the limits of automated harness generation, forcing confrontation with the very challenges that have hindered prior work. Third, solutions developed for Java's managed runtime and rich metadata naturally extend to similar ecosystems (Kotlin, Scala, .NET), amplifying broader impact.

We present a multi-agent architecture that orchestrates specialized LLM-based reasoning agents through a structured feedback loop. Our system decomposes harness generation into distinct phases (i.e., environment preparation, exploratory research, synthesis, validation, and refinement) each handled by dedicated agents equipped with domain-specific tools. Central to our approach is a tool-augmented reasoning framework that enables agents to query code structure, documentation, and implementation details on demand rather than relying on pre-computed summaries. Agents leverage Class Hierarchy Analysis to construct call graphs, retrieve API documentation from Javadoc archives, and examine source implementations—all through conversational exploration that adapts to the specific needs of each target library. Synthesis proceeds through iterative refinement guided by compilation diagnostics and coverage feedback, with separate agents specialized for generation (creative API exploration) and debugging (systematic error diagnosis). The result is a closed-loop workflow that autonomously produces compilable, coverage-optimized harnesses without requiring consumer code or manual intervention.

Our contributions advance the state of automated harness generation:
\begin{itemize}
    \item \textbf{A principled multi-agent architecture for end-to-end harness synthesis.} We introduce a workflow that decomposes harness generation into specialized reasoning tasks coordinated through adaptive feedback loops, eliminating reliance on consumer code, hand-crafted heuristics, or manual triage of build failures.

    \item \textbf{Model Context Protocol for tool-augmented code exploration.} We present an extensible framework enabling LLM agents to perform lazy, conversational queries against code analysis backends, thus transforming static analysis from a rigid preprocessing step into an adaptive reasoning resource.

    \item \textbf{Coverage-guided refinement} We demonstrate systematic improvement of harness quality through critic-agent collaboration, multi-criteria convergence detection, and cycle-aware exploration strategies that prevent semantic drift while maximizing achieved coverage.

    \item \textbf{Empirical validation on real-world Java libraries.} We evaluate our approach against established baselines including Jazzer's AutoFuzz and OSS-Fuzz-Gen, TODO: wir sind besser
\end{itemize}


\input{figures/overview.tex}
\input{sections/preliminaries.tex}
\input{sections/main-chapter.tex}
\input{sections/evaluation.tex}
\input{sections/related-work.tex}

\section{Conclusion and Outlook}
TODO


%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{main}


\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.