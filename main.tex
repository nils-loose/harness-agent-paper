\documentclass[sigconf,review,anonymous]{acmart}

\usepackage{listings}
\usepackage[inkscapeopt={-D}]{svg}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{pifont}
\usepackage{rotating}
\usepackage{listings}
\usepackage{xcolor}

\usepackage{placeins}
% YAML syntax highlighting - clean for academic papers
\lstdefinestyle{yaml}{
  basicstyle=\ttfamily\small,
  sensitive=false,
  comment=[l]{\#},
  commentstyle=\color{gray},
  showstringspaces=false,
  emphstyle=\bfseries,
  emph={get_method_code,description,method_signature,type,class_name,default},
  identifierstyle=,
  keywords={null, string},
}

% Java syntax highlighting
\definecolor{javared}{rgb}{0.6,0,0}          % for strings
\definecolor{javagreen}{rgb}{0.25,0.5,0.35}  % for comments
\definecolor{javapurple}{rgb}{0.5,0,0.35}    % for keywords
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75} % for javadoc

\lstset{language=Java,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{javapurple}\bfseries,
  stringstyle=\color{javared},
  commentstyle=\color{javagreen},
  morecomment=[s][\color{javadocblue}]{/**}{*/},
  showstringspaces=false,
  tabsize=2
}

% Define checkmark symbol
\newcommand{\cmark}{\ding{51}}

\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}
\acmConference[SBFT '26]{SEARCH-BASED AND FUZZ TESTING}{April 12--18,
  2026}{Rio de Janeiro, Brazil}
\acmISBN{978-1-4503-XXXX-X/2026/04}
\acmSubmissionID{123}
% Define text styles for SVG rendering
\def\axtext{\footnotesize\sffamily}
\def\ticktext{\scriptsize\sffamily}


\begin{document}

\title{Coverage-Guided Multi-Agent Harness Generation for Java Library Fuzzing}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Ben Trovato}
\authornote{Both authors contributed equally to this research.}
\email{trovato@corporation.com}
\orcid{1234-5678-9012}
\author{G.K.M. Tobin}
\authornotemark[1]
\email{webmaster@marysville-ohio.com}
\affiliation{%
  \institution{Institute for Clarity in Documentation}
  \city{Dublin}
  \state{Ohio}
  \country{USA}
}

\author{Lars Th{\o}rv{\"a}ld}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

\author{Valerie B\'eranger}
\affiliation{%
  \institution{Inria Paris-Rocquencourt}
  \city{Rocquencourt}
  \country{France}
}

\author{Aparna Patel}
\affiliation{%
 \institution{Rajiv Gandhi University}
 \city{Doimukh}
 \state{Arunachal Pradesh}
 \country{India}}

\author{Huifen Chan}
\affiliation{%
  \institution{Tsinghua University}
  \city{Haidian Qu}
  \state{Beijing Shi}
  \country{China}}

\author{Charles Palmer}
\affiliation{%
  \institution{Palmer Research Laboratories}
  \city{San Antonio}
  \state{Texas}
  \country{USA}}
\email{cpalmer@prl.com}

\author{John Smith}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \city{Hekla}
  \country{Iceland}}
\email{jsmith@affiliation.org}

\author{Julius P. Kumquat}
\affiliation{%
  \institution{The Kumquat Consortium}
  \city{New York}
  \country{USA}}
\email{jpkumquat@consortium.net}

\renewcommand{\shortauthors}{Trovato et al.}


\begin{abstract}
Coverage-guided fuzzing has proven effective for discovering vulnerabilities, but targeting library code requires specialized fuzz harnesses that translate fuzzer-generated inputs into valid API invocations. Manual harness creation is time-consuming and expertise-intensive, requiring deep understanding of API semantics, initialization sequences, and exception handling contracts.
We present a multi-agent architecture that automates fuzz harness generation for Java libraries through specialized LLM-powered agents. Five ReAct agents decompose the workflow into research, synthesis, compilation repair, coverage analysis, and refinement. Rather than preprocessing entire codebases, agents query documentation, source code, and callgraph information on demand through the Model Context Protocol, maintaining focused context while exploring complex dependencies.
To enable effective refinement, we introduce method-targeted coverage that tracks coverage only during target method execution to isolate target behavior, and agent-guided termination that examines uncovered source code to distinguish productive refinement opportunities from diminishing returns.
We evaluated our approach on seven target methods from six widely-deployed Java libraries totaling 115,000+ Maven dependents. Our generated harnesses achieve a median 26\% improvement over manually-written OSS-Fuzz baselines and outperform Jazzer AutoFuzz by 5\% in package-scope coverage. Generation costs average \$3.20 and 10 minutes per harness, making the approach practical for continuous fuzzing workflows. During 12-hour fuzzing campaigns, our generated harnesses discovered 3 unreported bugs in projects that are already integrated into OSS-Fuzz, demonstrating the effectiveness of the generated harnesses.
\end{abstract}
%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10010147.10010257</concept_id>
       <concept_desc>Computing methodologies~Machine learning</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007</concept_id>
       <concept_desc>Software and its engineering</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006</concept_id>
       <concept_desc>Software and its engineering~Software notations and tools</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10002978.10003022</concept_id>
       <concept_desc>Security and privacy~Software and application security</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computing methodologies~Machine learning}
\ccsdesc[500]{Software and its engineering}
\ccsdesc[500]{Software and its engineering~Software notations and tools}
\ccsdesc[500]{Security and privacy~Software and application security}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{fuzzing, fuzz harness generation, large language models, multi-agent systems, automated software testing, program analysis, feedback-driven refinement, Java ecosystem, coverage-guided fuzzing, software security}


\maketitle


\input{sections/introduction.tex}
\input{figures/overview.tex}
\input{sections/preliminaries.tex}
\input{sections/main-chapter.tex}
\input{sections/evaluation.tex}
\input{sections/related-work.tex}

\section{Conclusion}

We presented a multi-agent architecture that automates fuzzing harness generation for Java libraries through specialized ReAct agents and query-driven code analysis. Five agents decompose the workflow into research, synthesis, compilation repair, coverage analysis, and refinement, querying documentation and source code on demand through the Model Context Protocol. Method-targeted coverage instrumentation and agent-guided termination enable effective refinement without context saturation.

Evaluation on seven target methods from six widely deployed libraries demonstrates competitive coverage with manually written OSS-Fuzz baselines at practical costs of \$3.20 and 10 minutes per harness. Our harnesses discovered 3 previously unreported bugs in production libraries already integrated into OSS-Fuzz, validating that automated generation achieves sufficient quality for real vulnerability discovery. Future work includes extending to the system stateful APIs, identifying minimal method sets that maximize library coverage to reduce generation costs, and adapting the approach to synthesize property-based security harnesses that verify invariants beyond crash detection.

%\input{sections/threads-to-validity.tex}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{main}


\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.